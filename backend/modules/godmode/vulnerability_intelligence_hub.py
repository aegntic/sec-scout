"""
Vulnerability Intelligence Hub - Central coordination for automatic deep exploration
Integrates with all GODMODE modules to trigger comprehensive analysis and reporting
"""

import asyncio
import json
import logging
from datetime import datetime, timezone
from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass, asdict
from enum import Enum
import uuid

from .vulnerability_explorer import VulnerabilityExplorer, VulnerabilityContext, ExplorationDepth
from .auto_report_generator import AutoReportGenerator, ReportFormat, ReportAudience
from .swarm_intelligence_hub import SwarmIntelligenceHub
from .hive_mind_coordinator import HiveMindCoordinator

class TriggerCondition(Enum):
    ANY_VULNERABILITY = "any_vulnerability"
    HIGH_CONFIDENCE = "high_confidence"
    CRITICAL_SEVERITY = "critical_severity"
    MULTIPLE_VECTORS = "multiple_vectors"
    EXPLOITATION_CHAIN = "exploitation_chain"
    BUSINESS_CRITICAL = "business_critical"

class IntelligenceLevel(Enum):
    BASIC = "basic"
    ENHANCED = "enhanced"
    COMPREHENSIVE = "comprehensive"
    TRANSCENDENT = "transcendent"

@dataclass
class IntelligenceConfig:
    trigger_conditions: List[TriggerCondition]
    exploration_depth: ExplorationDepth
    intelligence_level: IntelligenceLevel
    auto_report_audiences: List[ReportAudience]
    real_time_notifications: bool
    integration_hooks: List[str]
    safety_constraints: Dict[str, Any]

@dataclass
class VulnerabilityIntelligence:
    vuln_id: str
    discovery_timestamp: str
    initial_finding: Dict[str, Any]
    exploration_results: Dict[str, Any]
    intelligence_report: Dict[str, Any]
    swarm_insights: Dict[str, Any]
    hive_mind_analysis: Dict[str, Any]
    automated_actions: List[Dict[str, Any]]
    notification_status: Dict[str, Any]

class VulnerabilityIntelligenceHub:
    def __init__(self, config: IntelligenceConfig = None):
        self.logger = logging.getLogger(__name__)
        self.config = config or self._default_config()
        
        # Initialize core components
        self.vulnerability_explorer = VulnerabilityExplorer()
        self.report_generator = AutoReportGenerator()
        self.swarm_hub = SwarmIntelligenceHub()
        self.hive_mind = HiveMindCoordinator()
        
        # Intelligence tracking
        self.active_investigations = {}
        self.intelligence_database = {}
        self.notification_handlers = {}
        self.integration_handlers = {}
        
        # Performance metrics
        self.metrics = {
            'total_vulnerabilities_processed': 0,
            'deep_explorations_triggered': 0,
            'reports_generated': 0,
            'automated_actions_taken': 0,
            'average_analysis_time': 0.0
        }
        
        self._initialize_handlers()

    def _default_config(self) -> IntelligenceConfig:
        """Create default intelligence configuration"""
        return IntelligenceConfig(
            trigger_conditions=[
                TriggerCondition.HIGH_CONFIDENCE,
                TriggerCondition.CRITICAL_SEVERITY,
                TriggerCondition.EXPLOITATION_CHAIN
            ],
            exploration_depth=ExplorationDepth.DEEP,
            intelligence_level=IntelligenceLevel.COMPREHENSIVE,
            auto_report_audiences=[
                ReportAudience.SECURITY_ENGINEER,
                ReportAudience.MANAGEMENT,
                ReportAudience.AI_SYSTEM
            ],
            real_time_notifications=True,
            integration_hooks=['slack', 'email', 'siem', 'ticketing'],
            safety_constraints={
                'max_concurrent_investigations': 10,
                'analysis_timeout': 3600,
                'prohibited_targets': ['production_critical'],
                'require_approval_for': ['destructive_tests']
            }
        )

    def _initialize_handlers(self):
        """Initialize notification and integration handlers"""
        self.notification_handlers = {
            'slack': self._send_slack_notification,
            'email': self._send_email_notification,
            'sms': self._send_sms_notification,
            'dashboard': self._update_dashboard
        }
        
        self.integration_handlers = {
            'siem': self._send_to_siem,
            'ticketing': self._create_ticket,
            'cicd': self._trigger_cicd_actions,
            'waf': self._update_waf_rules
        }

    async def process_vulnerability_finding(self, finding: Dict[str, Any], context: Dict[str, Any] = None) -> str:
        """Main entry point for processing vulnerability findings"""
        start_time = datetime.now(timezone.utc)
        investigation_id = str(uuid.uuid4())
        
        self.logger.info(f"Starting vulnerability intelligence processing [ID: {investigation_id}]")
        
        try:
            # Create vulnerability context
            vuln_context = self._create_vulnerability_context(finding, context)
            
            # Check trigger conditions
            if not await self._should_trigger_deep_analysis(finding, vuln_context):
                self.logger.info(f"Trigger conditions not met for {investigation_id}")
                return investigation_id
            
            # Initialize investigation
            investigation = {
                'investigation_id': investigation_id,
                'start_time': start_time,
                'status': 'active',
                'finding': finding,
                'context': vuln_context,
                'exploration_results': {},
                'intelligence_report': {},
                'swarm_insights': {},
                'hive_mind_analysis': {},
                'automated_actions': [],
                'notifications_sent': []
            }
            
            self.active_investigations[investigation_id] = investigation
            
            # Phase 1: Deep Vulnerability Exploration
            await self._execute_deep_exploration(investigation)
            
            # Phase 2: Swarm Intelligence Analysis
            await self._execute_swarm_analysis(investigation)
            
            # Phase 3: Hive Mind Coordination
            await self._execute_hive_mind_analysis(investigation)
            
            # Phase 4: Comprehensive Report Generation
            await self._generate_intelligence_reports(investigation)
            
            # Phase 5: Automated Actions and Notifications
            await self._execute_automated_actions(investigation)
            
            # Phase 6: Integration Hooks
            await self._trigger_integration_hooks(investigation)
            
            # Finalize investigation
            investigation['status'] = 'completed'
            investigation['end_time'] = datetime.now(timezone.utc)
            investigation['duration'] = (investigation['end_time'] - start_time).total_seconds()
            
            # Store in intelligence database
            vuln_intelligence = self._create_vulnerability_intelligence(investigation)
            self.intelligence_database[investigation_id] = vuln_intelligence
            
            # Update metrics
            self._update_metrics(investigation)
            
            self.logger.info(f"Vulnerability intelligence processing completed [ID: {investigation_id}]")
            return investigation_id
            
        except Exception as e:
            self.logger.error(f"Intelligence processing failed for {investigation_id}: {str(e)}")
            if investigation_id in self.active_investigations:
                self.active_investigations[investigation_id]['status'] = 'failed'
                self.active_investigations[investigation_id]['error'] = str(e)
            return investigation_id

    def _create_vulnerability_context(self, finding: Dict[str, Any], context: Dict[str, Any] = None) -> VulnerabilityContext:
        """Create vulnerability context from finding data"""
        context = context or {}
        
        return VulnerabilityContext(
            target_url=finding.get('target_url', context.get('target_url', 'unknown')),
            discovery_method=finding.get('discovery_method', context.get('discovery_method', 'automated')),
            initial_payload=finding.get('payload', finding.get('request', '')),
            response_indicators=finding.get('indicators', finding.get('evidence', [])),
            confidence_score=finding.get('confidence', 0.5),
            timestamp=datetime.now(timezone.utc).isoformat(),
            session_id=context.get('session_id', str(uuid.uuid4()))
        )

    async def _should_trigger_deep_analysis(self, finding: Dict[str, Any], context: VulnerabilityContext) -> bool:
        """Determine if deep analysis should be triggered based on conditions"""
        for condition in self.config.trigger_conditions:
            if await self._evaluate_trigger_condition(condition, finding, context):
                self.logger.info(f"Trigger condition met: {condition.value}")
                return True
        
        return False

    async def _evaluate_trigger_condition(self, condition: TriggerCondition, finding: Dict[str, Any], 
                                        context: VulnerabilityContext) -> bool:
        """Evaluate specific trigger condition"""
        if condition == TriggerCondition.ANY_VULNERABILITY:
            return True
        
        elif condition == TriggerCondition.HIGH_CONFIDENCE:
            return context.confidence_score >= 0.7
        
        elif condition == TriggerCondition.CRITICAL_SEVERITY:
            severity = finding.get('severity', '').lower()
            return severity in ['critical', 'high']
        
        elif condition == TriggerCondition.MULTIPLE_VECTORS:
            return len(finding.get('attack_vectors', [])) > 1
        
        elif condition == TriggerCondition.EXPLOITATION_CHAIN:
            return 'chain' in finding.get('description', '').lower()
        
        elif condition == TriggerCondition.BUSINESS_CRITICAL:
            return finding.get('business_impact', '').lower() in ['critical', 'high']
        
        return False

    async def _execute_deep_exploration(self, investigation: Dict[str, Any]) -> None:
        """Execute deep vulnerability exploration"""
        self.logger.info(f"Starting deep exploration for {investigation['investigation_id']}")
        
        try:
            exploration_result = await self.vulnerability_explorer.explore_vulnerability(
                investigation['finding'],
                investigation['context']
            )
            
            investigation['exploration_results'] = exploration_result
            self.metrics['deep_explorations_triggered'] += 1
            
        except Exception as e:
            self.logger.error(f"Deep exploration failed: {str(e)}")
            investigation['exploration_results'] = {'error': str(e)}

    async def _execute_swarm_analysis(self, investigation: Dict[str, Any]) -> None:
        """Execute swarm intelligence analysis"""
        self.logger.info(f"Starting swarm analysis for {investigation['investigation_id']}")
        
        try:
            # Prepare swarm analysis data
            swarm_data = {
                'vulnerability_data': investigation['finding'],
                'exploration_results': investigation['exploration_results'],
                'target_context': asdict(investigation['context'])
            }
            
            # Execute swarm intelligence analysis
            swarm_insights = await self.swarm_hub.analyze_vulnerability_with_swarm(swarm_data)
            investigation['swarm_insights'] = swarm_insights
            
        except Exception as e:
            self.logger.error(f"Swarm analysis failed: {str(e)}")
            investigation['swarm_insights'] = {'error': str(e)}

    async def _execute_hive_mind_analysis(self, investigation: Dict[str, Any]) -> None:
        """Execute hive mind coordination analysis"""
        self.logger.info(f"Starting hive mind analysis for {investigation['investigation_id']}")
        
        try:
            # Prepare hive mind analysis data
            hive_data = {
                'vulnerability_intelligence': investigation['exploration_results'],
                'swarm_insights': investigation['swarm_insights'],
                'global_context': self._get_global_threat_context()
            }
            
            # Execute hive mind analysis
            hive_analysis = await self.hive_mind.coordinate_global_response(hive_data)
            investigation['hive_mind_analysis'] = hive_analysis
            
        except Exception as e:
            self.logger.error(f"Hive mind analysis failed: {str(e)}")
            investigation['hive_mind_analysis'] = {'error': str(e)}

    async def _generate_intelligence_reports(self, investigation: Dict[str, Any]) -> None:
        """Generate comprehensive intelligence reports"""
        self.logger.info(f"Generating intelligence reports for {investigation['investigation_id']}")
        
        try:
            # Prepare comprehensive data for reporting
            report_data = {
                **investigation['exploration_results'],
                'swarm_insights': investigation['swarm_insights'],
                'hive_mind_analysis': investigation['hive_mind_analysis'],
                'investigation_metadata': {
                    'investigation_id': investigation['investigation_id'],
                    'start_time': investigation['start_time'].isoformat(),
                    'intelligence_level': self.config.intelligence_level.value
                }
            }
            
            # Generate comprehensive reports
            intelligence_report = await self.report_generator.generate_comprehensive_report(report_data)
            investigation['intelligence_report'] = intelligence_report
            self.metrics['reports_generated'] += 1
            
        except Exception as e:
            self.logger.error(f"Report generation failed: {str(e)}")
            investigation['intelligence_report'] = {'error': str(e)}

    async def _execute_automated_actions(self, investigation: Dict[str, Any]) -> None:
        """Execute automated actions based on intelligence findings"""
        self.logger.info(f"Executing automated actions for {investigation['investigation_id']}")
        
        try:
            # Determine automated actions based on findings
            actions = await self._determine_automated_actions(investigation)
            
            for action in actions:
                if await self._safety_check_action(action, investigation):
                    result = await self._execute_action(action, investigation)
                    investigation['automated_actions'].append({
                        'action': action,
                        'result': result,
                        'timestamp': datetime.now(timezone.utc).isoformat()
                    })
                    self.metrics['automated_actions_taken'] += 1
            
        except Exception as e:
            self.logger.error(f"Automated actions failed: {str(e)}")

    async def _trigger_integration_hooks(self, investigation: Dict[str, Any]) -> None:
        """Trigger integration hooks for external systems"""
        self.logger.info(f"Triggering integration hooks for {investigation['investigation_id']}")
        
        for hook in self.config.integration_hooks:
            if hook in self.integration_handlers:
                try:
                    await self.integration_handlers[hook](investigation)
                except Exception as e:
                    self.logger.error(f"Integration hook {hook} failed: {str(e)}")

    def _create_vulnerability_intelligence(self, investigation: Dict[str, Any]) -> VulnerabilityIntelligence:
        """Create vulnerability intelligence object from investigation"""
        return VulnerabilityIntelligence(
            vuln_id=investigation['finding'].get('id', investigation['investigation_id']),
            discovery_timestamp=investigation['start_time'].isoformat(),
            initial_finding=investigation['finding'],
            exploration_results=investigation['exploration_results'],
            intelligence_report=investigation['intelligence_report'],
            swarm_insights=investigation['swarm_insights'],
            hive_mind_analysis=investigation['hive_mind_analysis'],
            automated_actions=investigation['automated_actions'],
            notification_status=investigation.get('notifications_sent', [])
        )

    async def _determine_automated_actions(self, investigation: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Determine what automated actions should be taken"""
        actions = []
        
        # Extract key intelligence
        exploration = investigation.get('exploration_results', {})
        swarm = investigation.get('swarm_insights', {})
        hive_mind = investigation.get('hive_mind_analysis', {})
        
        # Critical vulnerability actions
        if self._is_critical_finding(exploration):
            actions.extend([
                {'type': 'immediate_notification', 'priority': 'critical', 'channels': ['slack', 'email', 'sms']},
                {'type': 'emergency_response', 'action': 'activate_incident_team'},
                {'type': 'containment', 'action': 'implement_emergency_blocks'}
            ])
        
        # High confidence exploitation actions
        if exploration.get('exploration_summary', {}).get('confidence_score', 0) > 0.8:
            actions.extend([
                {'type': 'security_alert', 'priority': 'high'},
                {'type': 'waf_rule_update', 'data': self._extract_waf_rules(exploration)},
                {'type': 'siem_alert', 'data': self._extract_siem_indicators(exploration)}
            ])
        
        # Swarm intelligence actions
        if swarm.get('collective_threat_level', 0) > 7:
            actions.extend([
                {'type': 'threat_intelligence_update', 'data': swarm},
                {'type': 'coordinated_defense', 'action': 'activate_swarm_defense'}
            ])
        
        # Hive mind strategic actions
        if hive_mind.get('global_impact_score', 0) > 8:
            actions.extend([
                {'type': 'strategic_response', 'action': 'global_threat_response'},
                {'type': 'intelligence_sharing', 'networks': ['threat_intel', 'security_community']}
            ])
        
        return actions

    async def _safety_check_action(self, action: Dict[str, Any], investigation: Dict[str, Any]) -> bool:
        """Safety check for automated actions"""
        # Check against safety constraints
        constraints = self.config.safety_constraints
        
        # Destructive action approval check
        if action.get('type') in constraints.get('require_approval_for', []):
            return False  # Require manual approval
        
        # Target safety check
        target = investigation['context'].target_url
        for prohibited in constraints.get('prohibited_targets', []):
            if prohibited in target:
                return False
        
        return True

    async def _execute_action(self, action: Dict[str, Any], investigation: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a specific automated action"""
        action_type = action.get('type')
        
        if action_type == 'immediate_notification':
            return await self._send_immediate_notifications(action, investigation)
        elif action_type == 'waf_rule_update':
            return await self._update_waf_rules_action(action, investigation)
        elif action_type == 'siem_alert':
            return await self._send_siem_alert(action, investigation)
        elif action_type == 'emergency_response':
            return await self._activate_emergency_response(action, investigation)
        else:
            return {'status': 'unknown_action', 'action_type': action_type}

    # Notification and Integration Methods
    async def _send_slack_notification(self, investigation: Dict[str, Any]) -> None:
        """Send Slack notification"""
        # Implementation would integrate with Slack API
        self.logger.info(f"Slack notification sent for {investigation['investigation_id']}")

    async def _send_email_notification(self, investigation: Dict[str, Any]) -> None:
        """Send email notification"""
        # Implementation would integrate with email service
        self.logger.info(f"Email notification sent for {investigation['investigation_id']}")

    async def _send_sms_notification(self, investigation: Dict[str, Any]) -> None:
        """Send SMS notification"""
        # Implementation would integrate with SMS service
        self.logger.info(f"SMS notification sent for {investigation['investigation_id']}")

    async def _update_dashboard(self, investigation: Dict[str, Any]) -> None:
        """Update real-time dashboard"""
        # Implementation would update dashboard
        self.logger.info(f"Dashboard updated for {investigation['investigation_id']}")

    async def _send_to_siem(self, investigation: Dict[str, Any]) -> None:
        """Send data to SIEM system"""
        # Implementation would integrate with SIEM
        self.logger.info(f"SIEM integration triggered for {investigation['investigation_id']}")

    async def _create_ticket(self, investigation: Dict[str, Any]) -> None:
        """Create support/security ticket"""
        # Implementation would integrate with ticketing system
        self.logger.info(f"Ticket created for {investigation['investigation_id']}")

    async def _trigger_cicd_actions(self, investigation: Dict[str, Any]) -> None:
        """Trigger CI/CD pipeline actions"""
        # Implementation would integrate with CI/CD systems
        self.logger.info(f"CI/CD actions triggered for {investigation['investigation_id']}")

    async def _update_waf_rules(self, investigation: Dict[str, Any]) -> None:
        """Update WAF rules based on findings"""
        # Implementation would integrate with WAF
        self.logger.info(f"WAF rules updated for {investigation['investigation_id']}")

    # Helper Methods
    def _get_global_threat_context(self) -> Dict[str, Any]:
        """Get global threat context for hive mind analysis"""
        return {
            'active_campaigns': len(self.active_investigations),
            'threat_landscape': 'elevated',
            'recent_patterns': ['sql_injection_surge', 'xss_variants']
        }

    def _is_critical_finding(self, exploration: Dict[str, Any]) -> bool:
        """Determine if finding is critical"""
        confidence = exploration.get('exploration_summary', {}).get('confidence_score', 0)
        successful_exploits = exploration.get('exploration_summary', {}).get('successful_exploitations', 0)
        return confidence > 0.9 and successful_exploits > 0

    def _extract_waf_rules(self, exploration: Dict[str, Any]) -> List[str]:
        """Extract WAF rules from exploration results"""
        return ['block suspicious SQL patterns', 'rate limit on vulnerable endpoints']

    def _extract_siem_indicators(self, exploration: Dict[str, Any]) -> List[str]:
        """Extract SIEM indicators from exploration results"""
        return ['unusual_query_patterns', 'elevated_error_rates']

    async def _send_immediate_notifications(self, action: Dict[str, Any], investigation: Dict[str, Any]) -> Dict[str, Any]:
        """Send immediate notifications for critical findings"""
        channels = action.get('channels', ['email'])
        results = {}
        
        for channel in channels:
            if channel in self.notification_handlers:
                try:
                    await self.notification_handlers[channel](investigation)
                    results[channel] = 'success'
                except Exception as e:
                    results[channel] = f'failed: {str(e)}'
        
        return results

    def _update_metrics(self, investigation: Dict[str, Any]) -> None:
        """Update performance metrics"""
        self.metrics['total_vulnerabilities_processed'] += 1
        
        duration = investigation.get('duration', 0)
        current_avg = self.metrics['average_analysis_time']
        total_processed = self.metrics['total_vulnerabilities_processed']
        
        # Update running average
        self.metrics['average_analysis_time'] = (
            (current_avg * (total_processed - 1) + duration) / total_processed
        )

    # Public API Methods
    def get_investigation_status(self, investigation_id: str) -> Dict[str, Any]:
        """Get status of specific investigation"""
        if investigation_id in self.active_investigations:
            return self.active_investigations[investigation_id]
        elif investigation_id in self.intelligence_database:
            return asdict(self.intelligence_database[investigation_id])
        else:
            return {'error': 'Investigation not found'}

    def get_intelligence_metrics(self) -> Dict[str, Any]:
        """Get intelligence hub metrics"""
        return {
            **self.metrics,
            'active_investigations': len(self.active_investigations),
            'total_intelligence_records': len(self.intelligence_database)
        }

    async def query_intelligence_database(self, query: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Query the vulnerability intelligence database"""
        # Implementation would support complex queries
        return [asdict(intel) for intel in self.intelligence_database.values()]

# Export main class
__all__ = ['VulnerabilityIntelligenceHub', 'IntelligenceConfig', 'TriggerCondition', 'IntelligenceLevel']